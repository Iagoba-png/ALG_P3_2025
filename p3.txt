Informe Práctica 3 Algoritmos

Xoel Queiro Lema
Iago Bescansa Alcoba
Raquel Varela Romaní

Grupo 1.3

07/11/2025
*****************************************

Para esta práctica implementamos y analizamos el comportamiento del algoritmo de ordenación rápida (quicksort), utilizando la mediana de 3 como estrategia de elección de pivote.
Hemos utilizado 3 umbrales distintos (1, 10, 100) a partir de los cuales se aplica el algoritmo de ordenación por inserción en lugar de seguir dividiendo recursivamente.

El objetivo es estudiar y comparar los tiempos obtenidos para cada umbral en función del estado inicial del vector (ascendente, descendente o aleatorio), determinar empíricamente la complejidad del algoritmo en cada caso, y finalmente, comparar los resultados obtenidos con los de la ordenación Shell de la pŕactica anterior (con la finalidad de evaluar cuál de los dos algoritmos es más eficiente).

La máquina utilizada fue:

Hardware: HP HP Pavilion x360 Convertible 14-dy1xxx 
RAM: 16,0 GiB
Procesador: 11th Gen Intel® Core™ i7-1195G7 CPU @ 2.90GHz × 8
SO: Ubuntu 22.04.5 LTS

*****************************************

Mediante los tests, comprobamos que el algoritmo funciona correctamente tanto para los distintos tamaños y estados iniciales del vector, como para los distintos umbrales.
Hemos probado con tamaños 10, 15 y 20, estados iniciales aleatorio, ascendente y descendente, y con umbrales 1, 10 y 100.

----TAMAÑO DEL VECTOR = 10 ----

---- UMBRAL = 1 ----

Caso ALEATORIO:
 -6 5 8 5 7 9 -5 -1 8 3
ordenado? 0
ordenando...
 -6 -5 -1 3 5 5 7 8 8 9
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9
ordenado? 1

Caso DESCENDENTE:
 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10
ordenado? 1

---- UMBRAL = 10 ----

Caso ALEATORIO:
 -4 0 -4 -8 -7 4 3 4 7 -7
ordenado? 0
ordenando...
 -8 -7 -7 -4 -4 0 3 4 4 7
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9
ordenado? 1

Caso DESCENDENTE:
 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10
ordenado? 1

---- UMBRAL = 100 ----

Caso ALEATORIO:
 -1 -5 -10 -1 -9 -3 -3 -3 -5 -4
ordenado? 0
ordenando...
 -10 -9 -5 -5 -4 -3 -3 -3 -1 -1
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9
ordenado? 1

Caso DESCENDENTE:
 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10
ordenado? 1

----TAMAÑO DEL VECTOR = 15 ----

---- UMBRAL = 1 ----

Caso ALEATORIO:
 -2 15 3 12 7 -9 -6 -6 0 -7 5 -15 14 -6 -11
ordenado? 0
ordenando...
 -15 -11 -9 -7 -6 -6 -6 -2 0 3 5 7 12 14 15
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
ordenado? 1

Caso DESCENDENTE:
 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
ordenado? 1

---- UMBRAL = 10 ----

Caso ALEATORIO:
 5 -5 -15 13 8 6 -12 -2 -6 -2 7 6 -2 -2 4
ordenado? 0
ordenando...
 -15 -12 -6 -5 -2 -2 -2 -2 4 5 6 6 7 8 13
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
ordenado? 1

Caso DESCENDENTE:
 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
ordenado? 1

---- UMBRAL = 100 ----

Caso ALEATORIO:
 1 9 4 -14 5 -5 -10 12 2 3 -10 -10 3 -14 -1
ordenado? 0
ordenando...
 -14 -14 -10 -10 -10 -5 -1 1 2 3 3 4 5 9 12
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
ordenado? 1

Caso DESCENDENTE:
 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
ordenado? 1

----TAMAÑO DEL VECTOR = 20 ----

---- UMBRAL = 1 ----

Caso ALEATORIO:
 -15 -9 2 -9 11 1 4 20 12 -16 -16 -16 11 -20 -6 -19 -8 5 -15 16
ordenado? 0
ordenando...
 -20 -19 -16 -16 -16 -15 -15 -9 -9 -8 -6 1 2 4 5 11 11 12 16 20
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
ordenado? 1

Caso DESCENDENTE:
 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
ordenado? 1

---- UMBRAL = 10 ----

Caso ALEATORIO:
 20 -6 -9 6 -13 9 5 -14 -8 -13 1 0 -1 -17 13 -9 4 -2 -9 -2
ordenado? 0
ordenando...
 -17 -14 -13 -13 -9 -9 -9 -8 -6 -2 -2 -1 0 1 4 5 6 9 13 20
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
ordenado? 1

Caso DESCENDENTE:
 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
ordenado? 1

---- UMBRAL = 100 ----

Caso ALEATORIO:
 3 -3 4 -7 -1 20 -4 12 4 1 9 5 17 -20 -8 -16 9 20 -10 -18
ordenado? 0
ordenando...
 -20 -18 -16 -10 -8 -7 -4 -3 -1 1 3 4 4 5 9 9 12 17 20 20
ordenado? 1

Caso ASCENDENTE:
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
ordenado? 1
ordenando...
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
ordenado? 1

Caso DESCENDENTE:
 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
ordenado? 0
ordenando...
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
ordenado? 1

*****************************************

Una vez comprobado que el funcionamiento es el correcto, pasamos a medir los tiempos de ejecución (en microsegundos).
En el programa hemos implementado 3 ejecuciones para sacar unas mejores mediciones.
Hemos puesto (*) para señalar las mediciones resultantes de un promedio de 1000 iteraciones, que se realiza cuando el tiempo es menor de 500 microsegundos.
Marcamos con un ($) las mediciones anómalas.


-> Ordenación rápida (Ascendente) (Umbral = 1)
Hemos utilizado: 
La función f(n) = t(n)/n^1.1 como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.25 para la cota sobreestimada.

              n                t(n)              t(n)/n          t(n)/n^1.1         t(n)/n^1.25
(*)            500            31.3250          0.0626500          0.0336530          0.0132489
(*)           1000            73.4930          0.0734930          0.0368338          0.0130691
(*)           2000           147.7690          0.0738845          0.0345502          0.0110483
(*)           4000           319.8720          0.0799680          0.0348907          0.0100554
              8000           652.0000          0.0815000          0.0331779          0.0086176
             16000          1467.0000          0.0916875          0.0348256          0.0081523
             32000          3219.0000          0.1005937          0.0356497          0.0075211
             64000          6609.0000          0.1032656          0.0341458          0.0064925
								(cte = 0.03)

-> Ordenación rápida (Ascendente) (Umbral = 10)
Hemos utilizado: 
La función f(n) = t(n)/(n*logn) como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.2 para la cota sobreestimada.

              n                t(n)              t(n)/n       t(n)/(n*logn)          t(n)/n^1.2
(*)            500            22.2260          0.0444520          0.0071528          0.0128262
(*)           1000            50.7490          0.0507490          0.0073467          0.0127476
(*)           2000           107.3820          0.0536910          0.0070638          0.0117407
(*)           4000           240.7040          0.0601760          0.0072553          0.0114554
              8000           534.0000          0.0667500          0.0074272          0.0110620
             16000          1166.0000          0.0728750          0.0075281          0.0105137
             32000          2504.0000          0.0782500          0.0075433          0.0098278
             64000          5626.0000          0.0879063          0.0079434          0.0096113
								(cte = 0.007)

-> Ordenación rápida (Ascendente) (Umbral = 100)
Hemos utilizado: 
La función f(n) = t(n)/(n^1.05*logn) como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.2 para la cota sobreestimada.

              n                t(n)              t(n)/n	      t(n)/(n^1.05 * logn)   t(n)/n^1.2
(*)            500            13.7170          0.0274340          0.0032354          0.0079158
(*)           1000            32.6380          0.0326380          0.0033449          0.0081983
(*)           2000            74.8700          0.0374350          0.0033679          0.0081860
(*)           4000           168.3820          0.0420955          0.0033525          0.0080135
(*)           8000           383.9890          0.0479986          0.0034076          0.0079545
             16000           824.0000          0.0515000          0.0032788          0.0074299
             32000          1802.0000          0.0563125          0.0032316          0.0070725
             64000          3943.0000          0.0616094          0.0032013          0.0067361
								(cte = 0.003)

En los vectores ascendentes (mejor caso), observamos que las complejidades tienden a O(n*logn), especialmente para los umbrales 10 y 100. Esto indica que el crecimiento empírico se aproxima más a O(n·logn) que a O(n), ya que las cotas lineales (t(n)/n) muestran un aumento progresivo con el tamaño del vector, mientras que las cotas con factor logarítmico se mantienen estables. Al aumentar el umbral el rendimiento mejora, ya que la ordenación por inserción en vectores más pequeños es más eficiente.


-> Ordenación rápida (Descendente) (Umbral = 1)
Hemos utilizado: 
La función f(n) = t(n)/n^1.08 como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.18 para la cota sobreestimada.

              n                t(n)              t(n)/n         t(n)/n^1.08         t(n)/n^1.18
(*)            500            31.7180          0.0634360          0.0385850          0.0207263
(*)           1000            69.7130          0.0697130          0.0401156          0.0201054
(*)           2000           153.8040          0.0769020          0.0418654          0.0195773
(*)           4000           323.6780          0.0809195          0.0416762          0.0181837
              8000           698.0000          0.0872500          0.0425127          0.0173065
             16000          1429.0000          0.0893125          0.0411702          0.0156376
             32000          3085.0000          0.0964062          0.0420430          0.0148997
             64000          6332.0000          0.0989375          0.0408194          0.0134974
								(cte = 0.04)

-> Ordenación rápida (Descendente) (Umbral = 10)
Hemos utilizado: 
La función f(n) = t(n)/n^1.15 como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.25 para la cota sobreestimada.

              n                t(n)              t(n)/n         t(n)/n^1.15         t(n)/n^1.25
(*)            500            22.1430          0.0442860          0.0174350          0.0093653
(*)           1000            48.3130          0.0483130          0.0171421          0.0085914
(*)           2000           113.7970          0.0568985          0.0181948          0.0085083
(*)           4000           236.9630          0.0592408          0.0170731          0.0074491
(*)           8000           506.1250          0.0632656          0.0164325          0.0066895
             16000          1093.0000          0.0683125          0.0159912          0.0060739
             32000          2421.0000          0.0756562          0.0159614          0.0056566
             64000          4961.0000          0.0775156          0.0147388          0.0048735
								(cte = 0.01)

-> Ordenación rápida (Descendente) (Umbral = 100)
Hemos utilizado: 
La función f(n) = t(n)/n^1.15 como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.25 para la cota sobreestimada.

              n                t(n)              t(n)/n         t(n)/n^1.15         t(n)/n^1.25
(*)            500            13.3320          0.0266640          0.0104974          0.0056387
(*)           1000            31.6170          0.0316170          0.0112181          0.0056224
(*)           2000            77.8060          0.0389030          0.0124402          0.0058174
(*)           4000           170.6100          0.0426525          0.0122924          0.0053633
(*)           8000           379.6140          0.0474517          0.0123251          0.0050174
             16000           841.0000          0.0525625          0.0123043          0.0046735
             32000          2002.0000          0.0625625          0.0131990          0.0046776
             64000          3977.0000          0.0621406          0.0118154          0.0039069
								(cte = 0.01)

En el caso de los vectores ordenados descendentes, observamos que la complejidad empírica se aproxima a O(n^1.15) para los umbrales 10 y 100, mientras que para umbral 1 la complejidad es de O(n^1.08). Aunque el caso descendente es el más desfavorable para el algoritmo, el aumento del umbral mejora el rendimiento.


-> Ordenación rápida (Aleatorio) (Umbral = 1)
Hemos utilizado: 
La función f(n) = t(n)/(n*logn) como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.18 para la cota sobreestimada.

              n                t(n)              t(n)/n       t(n)/(n*logn)         t(n)/n^1.18
(*)            500            94.2310          0.1884620          0.0303256          0.0615757
(*)           1000           191.2930          0.1912930          0.0276925          0.0551695
(*)           2000           403.6540          0.2018270          0.0265530          0.0513800
              4000           889.0000          0.2222500          0.0267963          0.0499426
              8000          1910.0000          0.2387500          0.0265656          0.0473573
             16000          4105.0000          0.2565625          0.0265034          0.0449212
             32000          8779.0000          0.2743437          0.0264466          0.0424002
             64000         18599.0000          0.2906094          0.0262600          0.0396458
								(cte = 0.02)

-> Ordenación rápida (Aleatorio) (Umbral = 10)
Hemos utilizado: 
La función f(n) = t(n)/(n*logn) como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.18 para la cota sobreestimada.

              n                t(n)              t(n)/n       t(n)/(n*logn)         t(n)/n^1.18
(*)            500            85.6520          0.1713040          0.0275647          0.0559697
(*)           1000           190.1100          0.1901100          0.0275212          0.0548283
(*)           2000           418.1770          0.2090885          0.0275084          0.0532286
              4000           898.0000          0.2245000          0.0270676          0.0504482
              8000          1956.0000          0.2445000          0.0272054          0.0484979
             16000          4047.0000          0.2529375          0.0261290          0.0442865
             32000          8828.0000          0.2758750          0.0265942          0.0426369
             64000         19621.0000          0.3065781          0.0277029          0.0418243
								(cte = 0.02)

-> Ordenación rápida (Aleatorio) (Umbral = 100)
Hemos utilizado: 
La función f(n) = t(n)/(n*logn) como cota ajustada
La función f(n) = t(n)/n para la cota subestimada
La función f(n) = t(n)/n^1.18 para la cota sobreestimada.

              n                t(n)              t(n)/n       t(n)/(n*logn)         t(n)/n^1.18
(*)            500            86.5600          0.1731200          0.0278569          0.0565630
(*)           1000           194.6160          0.1946160          0.0281736          0.0561279
(*)           2000           415.4520          0.2077260          0.0273291          0.0528817
              4000           903.0000          0.2257500          0.0272183          0.0507291
              8000          1987.0000          0.2483750          0.0276365          0.0492665
             16000          4196.0000          0.2622500          0.0270910          0.0459170
             32000          8866.0000          0.2770625          0.0267087          0.0428204
             64000         19007.0000          0.2969844          0.0268360          0.0405155
								(cte = 0.02)

En el caso de los vectores aleatorios (caso medio), comprobamos que la complejidad empírica es de O(n*logn) para todos los umbrales, lo que demuestra que es el algoritmo más eficiente de los analizados en esta práctica, por su crecimiento logarítmico.

*****************************************

Tras analizar los resultados obtenidos, podemos afirmar que los casos ascendente y aleatorio presentan un crecimiento logarítmico, O(n·log n), lo que los hace los casos más eficientes. Mientras que el caso descendente,la complejidad empírica se aproxima a O(n^1.15), por lo que es el caso menos eficiente.
En cuanto al umbral, aumentarlo reduce la recursividad, y mejora los timpos de ejecución de los casos ascendente y aleatorio (U=100 < U=10 < U=1), mientras que en descendente nuestras mediciones muestran U=10 como opción más rápida, seguida de U=1 y finalmente U=100.

Por orden de más eficiente a menos quedarían:
1. Ascendente umbral 100
2. Aleatorio umbral 100
3. Ascendente umbral 10
4. Aleatorio umbral 10
5. Ascendente umbral 1
6. Aleatorio umbral 1
7. Descendente umbral 10
8. Descendente umbral 1
9. Descendente umbral 100

Finalmente, vamos a comparar los resultados obtenidos de la ordenación rápida con los resultados de la ordenación shell de la práctica anterior (para vectores inicializados aleatorios).
Vamos a tomar como referencia n = 32000 por ejemplo.
En la anterior práctica para n = 32000 obtuvimos estos resultados:
					n	t(n)   subestimada  ajustada  sobreestimada
-> Ordenación Shell con Hibbard ->   32000  16008.0000  0.5002500  0.1055394  0.0222660
-> Ordenación Shell con Knuth ->     32000  14299.0000  0.4468437  0.0942721  0.0198889
-> Ordenación Shell con Sedgewick -> 32000  12192.0000  0.3810000  0.1097254  0.0478514
-> Ordenación Shell con Ciura ->     32000  13001.0000  0.4062812  0.1170062  0.0510266

-> Aleatorio umbral 1 ->	     32000  8779.0000   0.2743437  0.0264466  0.0424002
-> Aleatorio umbral 10 ->	     32000  8828.0000   0.2758750  0.0265942  0.0426369
-> Aleatorio umbral 100	->	     32000  8866.0000   0.2770625  0.0267087  0.0428204

Comprobamos como en tiempos de ejecución Quicksort es más eficiente y más rápido que cualquier incremento de Shell. Además, la ordenación shell tiene una complejidad empírica de entre O(n^1.12) y O(n^1.15), y ordenación quicksort de O(n*logn) por lo que su crecimiento de tiempos es más lento.

